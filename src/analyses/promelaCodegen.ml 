open Prelude
open Cil
open Deriving.Cil
open PthreadAnalysis

(*
 * (\** promela source code *\)
 * type promela_src = string
 *
 * (\* module type Ctx = sig
 *  *   open PthreadCodeSlicer
 *  *
 *  *   type t
 *  *
 *  *   type edge = node * action * node
 *  *
 *  *   val get_edges : t -> resource_id -> edge Set.t
 *  *
 *  *   val get_id_from_resource : t -> resource_id -> int
 *  *
 *  *   val get_resources : t -> resource_id list
 *  *
 *  *   val get_fun_name_for_proc : t -> process_name -> fun_name option
 *  *
 *  *   val get_prio_for_proc : t -> process_name -> int64 option
 *  * end *\)
 *
 * module PromelaCodegen : sig
 *   (\* val init : unit -> promela_src
 *    * (\\** [init_body ()] map init/main function to `promela_src` *\\)
 *    *
 *    * val resource_def : Ctx.t -> resource_id -> promela_src
 *    * (\\** [resource_def id] maps [resource_id] resource to `promela_src`*\\)
 *    *
 *    * val codegen : Ctx.t -> promela_src
 *    * (\\** [codegen edges] generates `promela_src` from the analyzed and sliced program *\\) *\)
 *
 * end = struct
 *   let tabulate s = "\t" ^ s
 *
 *   (\* let init () =
 *    *   let init_lines = [ "" ] in
 *    *   let init_body = List.map tabulate init_lines |> String.concat "\n" in
 *    *   "init {" ^ init_body ^ "}"
 *    *
 *    *
 *    * let rec resource_def ctx ((resource_type, resource_name) as id) =
 *    *   let pid = id |> Ctx.get_resource_id ctx |> string_of_int in
 *    *   let fun_name =
 *    *     resource_name |> Ctx.get_fun_name_for_proc ctx |> Option.get
 *    *   in
 *    *   (\\* shouldn't this be unnecessary since I have different resource types, including functions *\\)
 *    *   let is_proc = resource_name = fun_name in
 *    *   let promela_name =
 *    *     let prefix = if is_proc then "P_" else "F_" in
 *    *     prefix ^ resource_type
 *    *   in
 *    *   let head =
 *    *     if is_proc
 *    *     then
 *    *       (\\* process *\\)
 *    *       let prio =
 *    *         match Ctx.get_prio_for_proc ctx resource_name with
 *    *         | Some x ->
 *    *             " priority " ^ Int64.to_string x
 *    *         | None ->
 *    *             ""
 *    *       in
 *    *       "proctype "
 *    *       ^ resource_type
 *    *       ^ "(byte tid)"
 *    *       ^ prio
 *    *       ^ " provided (can_run("
 *    *       ^ pid
 *    *       ^ ") PRIO"
 *    *       ^ pid
 *    *       ^ ") {\n  int stack[20]; int sp = -1;"
 *    *     else (\\* some function call in process *\\)
 *    *       "Fun_" ^ resource_name ^ ":"
 *    *   in
 *    *   (\\* build adjacency matrix for all nodes of this process *\\)
 *    *   let module HashtblN = Hashtbl.Make (ArincDomain.Pred.Base) in
 *    *   let a2bs = HashtblN.create 97 in
 *    *   Set.iter
 *    *     (fun ((a, _, b) as edge) ->
 *    *       HashtblN.modify_def Set.empty a (Set.add edge) a2bs)
 *    *     (Ctx.get_edges ctx id) ;
 *    *   let nodes = HashtblN.keys a2bs |> List.of_enum in
 *    *   (\\* let out_edges node = HashtblN.find_default a2bs node Set.empty |> Set.elements in (\\* Set.empty leads to Out_of_memory!? *\\) *\\)
 *    *   let out_edges node =
 *    *     try node |> HashtblN.find a2bs |> Set.elements with Not_found -> []
 *    *   in
 *    *   let in_edges node =
 *    *     a2bs
 *    *     |> HashtblN.filter (Set.mem node % Set.map Tuple3.third)
 *    *     |> HashtblN.values
 *    *     |> List.of_enum
 *    *     |> flat_map Set.elements
 *    *   in
 *    *   let is_end_node = List.is_empty % out_edges in
 *    *   let is_start_node = List.is_empty % in_edges in
 *    *   let start_node = List.find is_start_node nodes in
 *    *   (\\* node with no incoming edges is the start node *\\)
 *    *   let label n = promela_name ^ "_" ^ Pred.string_of_elt n in
 *    *   let end_label = promela_name ^ "_end" in
 *    *   let goto label = "goto " ^ label ^ ";" in
 *    *   let codegen_edge (a, action, b) =
 *    *     let target_label = if is_end_node b then end_label else label b in
 *    *     let str_action =
 *    *       match action with
 *    *       | Call fun_name ->
 *    *           let pc = FunCallTbl.get (fun_name, target_label) |> string_of_int in
 *    *           "mark(" ^ pc ^ "); " ^ goto ("Fun_" ^ fun_name)
 *    *       | Sys x ->
 *    *           x
 *    *     in
 *    *     (\\* for function calls the goto will never be reached since the function's return will already jump to that label; however it's nice to see where the program will continue at the site of the call. *\\)
 *    *     str_action ^ " " ^ goto target_label
 *    *   in
 *    *   let walk_edges (a, out_edges) =
 *    *     let edges = Set.elements out_edges |> List.map codegen_edge in
 *    *     let body =
 *    *       if List.length edges > 1
 *    *       then
 *    *         (\\* choices in if-statements are prefixed with :: *\\)
 *    *         let prefix_branch x = "::" ^ tabulate x in
 *    *         let if_branches = List.map prefix_branch edges in
 *    *         [ "if" ] @ if_branches @ [ "fi" ]
 *    *       else edges
 *    *     in
 *    *     (label a ^ ":") :: body
 *    *   in
 *    *   let locals = [] in
 *    *   let return =
 *    *     if is_proc then " status[tid] = DONE" else " ret_" ^ resource_name ^ "()"
 *    *   in
 *    *   let body =
 *    *     locals
 *    *     @ [ goto (label start_node) ]
 *    *     @ flat_map walk_edges (HashtblN.enum a2bs |> List.of_enum)
 *    *     @ [ end_label ^ ":" ^ return ]
 *    *   in
 *    *   String.concat "\n"
 *    *   @@ (head :: List.map tabulate body)
 *    *   @ [ (if is_proc then "}\n" else "") ]
 *    *
 *    *
 *    * let codegen ctx =
 *    *   let resource_defs =
 *    *     ctx |> Ctx.get_resources |> List.map (fun id -> resource_def ctx id)
 *    *   in
 *    *   let code_components = [ init () ] @ resource_defs in
 *    *   String.concat "\n" code_components *\)
 *
 *   let save_promela_model () =
 *     let open Action in
 *     (\* needed to distinguish the record field names from the ones of D.t *\)
 *     let indent = tabulate in
 *     let threads =
 *       List.unique
 *       @@ filter_map_actions (function CreateProcess x -> Some x | _ -> None)
 *     in
 *     let has_error_handler =
 *       not
 *       @@ List.is_empty
 *       @@ filter_actions (function CreateErrorHandler _ -> true | _ -> false)
 *     in
 *     let bboards =
 *       List.unique
 *       @@ filter_map_actions (function
 *              | CreateBlackboard id ->
 *                  Some id
 *              | _ ->
 *                  None)
 *     in
 *     let semas =
 *       List.unique
 *       @@ filter_map_actions (function CreateSemaphore x -> Some x | _ -> None)
 *     in
 *     let events =
 *       List.unique
 *       @@ filter_map_actions (function CreateEvent id -> Some id | _ -> None)
 *     in
 *     let nproc = List.length procs + 1 + if has_error_handler then 1 else 0 in
 *     (\* +1 is init process *\)
 *     let nbboard = List.length bboards in
 *     let nsema = List.length semas in
 *     let nevent = List.length events in
 *     let run_processes =
 *       List.map
 *         (fun x ->
 *           let name = snd x.pid in
 *           let id = id_pml x.pid in
 *           (id, "run " ^ name ^ "(" ^ Int64.to_string id ^ ");"))
 *         procs
 *       |> List.sort (compareBy fst)
 *       |> List.map snd
 *     in
 *     let init_body =
 *       (\* keep mainfun as name for init process? *\)
 *       "preInit;"
 *       :: "run mainfun(0);"
 *       :: "postInit();"
 *       :: "run monitor();"
 *       :: ( if has_error_handler
 *          then "run ErrorHandler(" ^ str_id_pml (Process, "ErrorHandler") ^ ")"
 *          else "// no ErrorHandler" )
 *       :: run_processes
 *     in
 *     let current_pname = ref "" in
 *     let called_funs_done = ref Set.empty in
 *     let rec process_def id =
 *       if fst id = Function && Set.mem (snd id) !called_funs_done
 *       then []
 *       else
 *         (\* if we already generated code for this function, we just return [] *\)
 *         let iid = id_pml id in
 *         (\* id is type*name, iid is int64 (starting from 0 for each type of resource) *\)
 *         let spid = str_pid_pml id in
 *         (\* string for id (either Function or Process) *\)
 *         (\* set the name of the current process (this function is also run for functions, which need a reference to the process for checking branching on return vars) *\)
 *         if fst id = Process then current_pname := snd id ;
 *         (\* for a process we start with no called functions, for a function we add its name *\)
 *         called_funs_done :=
 *           if fst id = Process
 *           then Set.empty
 *           else Set.add (snd id) !called_funs_done ;
 *         (\* build adjacency matrix for all nodes of this process *\)
 *         let module HashtblN = Hashtbl.Make (ArincDomain.Pred.Base) in
 *         let a2bs = HashtblN.create 97 in
 *         Set.iter
 *           (fun ((a, _, _, b) as edge) ->
 *             HashtblN.modify_def Set.empty a (Set.add edge) a2bs)
 *           (get_edges id) ;
 *         let nodes = HashtblN.keys a2bs |> List.of_enum in
 *         (\* let out_edges node = HashtblN.find_default a2bs node Set.empty |> Set.elements in (\* Set.empty leads to Out_of_memory!? *\) *\)
 *         let out_edges node =
 *           try HashtblN.find a2bs node |> Set.elements with Not_found -> []
 *         in
 *         let in_edges node =
 *           HashtblN.filter (Set.mem node % Set.map get_b) a2bs
 *           |> HashtblN.values
 *           |> List.of_enum
 *           |> flat_map Set.elements
 *         in
 *         let is_end_node = List.is_empty % out_edges in
 *         let is_start_node = List.is_empty % in_edges in
 *         let start_node = List.find is_start_node nodes in
 *         (\* node with no incoming edges is the start node *\)
 *         (\* let str_nodes xs = "{"^(List.map string_of_node xs |> String.concat ",")^"}" in *\)
 *         let label n = spid ^ "_" ^ string_of_node n in
 *         let end_label = spid ^ "_end" in
 *         let goto node = "goto " ^ label node in
 *         let called_funs = ref [] in
 *         let str_edge (a, action, r, b) =
 *           let target_label = if is_end_node b then end_label else label b in
 *           let mark =
 *             match action with
 *             | Call fname ->
 *                 called_funs := fname :: !called_funs ;
 *                 let pc = string_of_int @@ FunTbl.get (fname, target_label) in
 *                 "mark(" ^ pc ^ "); "
 *             | _ ->
 *                 ""
 *           in
 *           (\* for function calls the goto will never be reached since the function's return will already jump to that label; however it's nice to see where the program will continue at the site of the call. *\)
 *           mark
 *           ^ str_action_pml (Process, !current_pname) r action
 *           ^ " goto "
 *           ^ target_label
 *         in
 *         let choice xs = List.map (fun x -> "::\t" ^ x) xs in
 *         (\* choices in if-statements are prefixed with :: *\)
 *         let walk_edges (a, out_edges) =
 *           let edges = Set.elements out_edges |> List.map str_edge in
 *           (label a ^ ":")
 *           ::
 *           ( if List.length edges > 1
 *           then ("if" :: choice edges) @ [ "fi" ]
 *           else edges )
 *         in
 *         let locals =
 *           if (not @@ GobConfig.get_bool "ana.arinc.assume_success")
 *              && fst id = Process
 *           then get_locals id
 *           else []
 *         in
 *         let body =
 *           locals
 *           @ goto start_node
 *             :: flat_map walk_edges (HashtblN.enum a2bs |> List.of_enum)
 *           @ [ ( end_label
 *               ^ ":"
 *               ^
 *               if fst id = Process
 *               then " status[id] = DONE"
 *               else " ret_" ^ snd id ^ "()" )
 *             ]
 *         in
 *         let head =
 *           match id with
 *           | Process, name ->
 *               let proc = find_option (fun x -> x.pid = id) procs in
 *               (\* None for mainfun *\)
 *               let priority =
 *                 match proc with
 *                 | Some proc ->
 *                     " priority " ^ Int64.to_string proc.pri
 *                 | _ ->
 *                     ""
 *               in
 *               "proctype "
 *               ^ name
 *               ^ "(byte id)"
 *               ^ priority
 *               ^ " provided (canRun("
 *               ^ Int64.to_string iid
 *               ^ ") PRIO"
 *               ^ Int64.to_string iid
 *               ^ ") {\nint stack[20]; int sp = -1;"
 *           | Function, name ->
 *               "Fun_" ^ name ^ ":"
 *           | _ ->
 *               failwith
 *                 "Only Process and Function are allowed as keys for collecting \
 *                  ARINC actions"
 *         in
 *         let called_fun_ids =
 *           List.map (fun fname -> (Function, fname)) !called_funs
 *         in
 *         let funs = flat_map process_def called_fun_ids in
 *         ("" :: head :: List.map indent body)
 *         @ funs
 *         @ [ (if fst id = Process then "}" else "") ]
 *     in
 *     (\* used for macros oneIs, allAre, noneAre... *\)
 *     let checkStatus =
 *       "("
 *       ^ ( String.concat " op2 "
 *         @@ List.of_enum
 *         @@ ((0 --^ nproc) /@ fun i -> "status[" ^ string_of_int i ^ "] op1 v")
 *         )
 *       ^ ")"
 *     in
 *     let allTasks =
 *       "("
 *       ^ ( String.concat " && "
 *         @@ List.of_enum
 *         @@ ((0 --^ nproc) /@ fun i -> "prop(" ^ string_of_int i ^ ")") )
 *       ^ ")"
 *     in
 *     (\* generate priority based running constraints for each process (only used ifdef PRIOS): process can only run if no higher prio process is ready *\)
 *     let prios =
 *       let def proc =
 *         let id = str_id_pml proc.pid in
 *         let pri = proc.pri in
 *         let higher = List.filter (fun x -> x.pri > pri) procs in
 *         if List.is_empty higher
 *         then None
 *         else
 *           Some
 *             ( "#undef PRIO"
 *             ^ id
 *             ^ "\n#define PRIO"
 *             ^ id
 *             ^ String.concat ""
 *             @@ List.map
 *                  (fun x -> " && status[" ^ str_id_pml x.pid ^ "] != READY")
 *                  higher )
 *       in
 *       List.filter_map def procs
 *     in
 *     (\* sort definitions so that inline functions come before the processes *\)
 *     let process_defs =
 *       Hashtbl.keys !edges
 *       |> List.of_enum
 *       |> List.filter (fun id -> fst id = Process)
 *       |> List.sort (compareBy str_pid_pml)
 *       |> flat_map process_def
 *     in
 *     let fun_mappings =
 *       let fun_map xs =
 *         if List.is_empty xs
 *         then []
 *         else
 *           let (name, _), _ = List.hd xs in
 *           let entries =
 *             xs
 *             |> List.map (fun ((_, k), v) ->
 *                    "\t:: (stack[sp] == "
 *                    ^ string_of_int v
 *                    ^ ") -> sp--; goto "
 *                    ^ k
 *                    ^ " \\")
 *           in
 *           let debug_str =
 *             if GobConfig.get_bool "ana.pml.debug"
 *             then "\t:: else -> printf(\"wrong pc on stack!\"); assert(false) "
 *             else ""
 *           in
 *           (("#define ret_" ^ name ^ "() if \\") :: entries)
 *           @ [ debug_str ^ "fi" ]
 *       in
 *       FunTbl.to_list ()
 *       |> List.group (compareBy (fst % fst))
 *       |> flat_map fun_map
 *     in
 *     let promela =
 *       String.concat "\n"
 *       @@ ("#define nproc " ^ string_of_int nproc)
 *          :: ("#define nbboard " ^ string_of_int nbboard)
 *          :: ("#define nsema " ^ string_of_int nsema)
 *          :: ("#define nevent " ^ string_of_int nevent)
 *          :: ""
 *          :: ("#define checkStatus(op1, v, op2) " ^ checkStatus)
 *          :: ""
 *          :: ("#define allTasks(prop) " ^ allTasks)
 *          :: ""
 *          :: "#include \"arinc.base.pml\""
 *          :: ""
 *          :: "init {"
 *          :: List.map indent init_body
 *       @ "}"
 *         :: ""
 *         :: ( List.of_enum
 *            @@ ((0 --^ nproc) /@ fun i -> "#define PRIO" ^ string_of_int i) )
 *       @ ("#ifdef PRIOS" :: prios)
 *       @ ("#endif" :: "" :: fun_mappings)
 *       @ ("" :: get_globals ())
 *       @ process_defs
 *     in
 *     save_result "promela model" "pml" promela ;
 *     print_endline
 *       "Copy spin/arinc_base.pml to same folder and then do: spin -a arinc.pml \
 *        && cc -o pan pan.c && ./pan"
 * end *)
